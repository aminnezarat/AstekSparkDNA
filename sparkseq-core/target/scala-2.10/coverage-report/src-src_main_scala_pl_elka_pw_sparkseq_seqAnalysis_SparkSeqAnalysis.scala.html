<table class="classes"><tbody><tr>
      <td class="barContainerLeft"><a href="#">&#x200B;pl/&#x200B;elka/&#x200B;pw/&#x200B;sparkseq/&#x200B;seqAnalysis/<span class="header">&#x200B;SparkSeqAnalysis.scala</span></a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">91 %(124 out of 136)</div>
        <div class="greenBar" style="width:182px;">&nbsp;</div>
      </div>
    </div></td>
    </tr><tr>
      <td class="barContainerLeft"><a href="src-src_main_scala_pl_elka_pw_sparkseq_seqAnalysis_SparkSeqAnalysis.scala.html#Class_pl_elka_pw_sparkseq_seqAnalysis_SparkSeqAnalysis"><img src="class.png"/>SparkSeqAnalysis</a></td>
      <td class="barContainerRight"><div class="percentages">
      <div class="bar">
        <div class="percentage">91 %(124 out of 136)</div>
        <div class="greenBar" style="width:182px;">&nbsp;</div>
      </div>
    </div></td>
    </tr></tbody></table><table class="source"><tbody><tr>
            <td class="black">1</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">2</td>
            <td> * Copyright (c) 2014. [insert your company or name here]
</td>
          </tr><tr>
            <td class="black">3</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">4</td>
            <td> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
</td>
          </tr><tr>
            <td class="black">5</td>
            <td> * you may not use this file except in compliance with the License.
</td>
          </tr><tr>
            <td class="black">6</td>
            <td> * You may obtain a copy of the License at
</td>
          </tr><tr>
            <td class="black">7</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">8</td>
            <td> *     http://www.apache.org/licenses/LICENSE-2.0
</td>
          </tr><tr>
            <td class="black">9</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">10</td>
            <td> * Unless required by applicable law or agreed to in writing, software
</td>
          </tr><tr>
            <td class="black">11</td>
            <td> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
</td>
          </tr><tr>
            <td class="black">12</td>
            <td> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
</td>
          </tr><tr>
            <td class="black">13</td>
            <td> * See the License for the specific language governing permissions and
</td>
          </tr><tr>
            <td class="black">14</td>
            <td> * limitations under the License.
</td>
          </tr><tr>
            <td class="black">15</td>
            <td> */
</td>
          </tr><tr>
            <td class="black">16</td>
            <td>package pl.elka.pw.sparkseq.seqAnalysis
</td>
          </tr><tr>
            <td class="black">17</td>
            <td>
</td>
          </tr><tr>
            <td class="black">18</td>
            <td>import org.apache.spark.SparkContext
</td>
          </tr><tr>
            <td class="black">19</td>
            <td>import SparkContext._
</td>
          </tr><tr>
            <td class="black">20</td>
            <td>import org.apache.spark.rdd._
</td>
          </tr><tr>
            <td class="black">21</td>
            <td>import org.apache.spark._
</td>
          </tr><tr>
            <td class="black">22</td>
            <td>import fi.tkk.ics.hadoop.bam.BAMInputFormat
</td>
          </tr><tr>
            <td class="black">23</td>
            <td>import fi.tkk.ics.hadoop.bam.SAMRecordWritable
</td>
          </tr><tr>
            <td class="black">24</td>
            <td>import org.apache.hadoop.io.LongWritable
</td>
          </tr><tr>
            <td class="black">25</td>
            <td>import scala.util.control._
</td>
          </tr><tr>
            <td class="black">26</td>
            <td>import scala.collection.mutable.ArrayBuffer
</td>
          </tr><tr>
            <td class="black">27</td>
            <td>import pl.elka.pw.sparkseq.conversions.SparkSeqConversions
</td>
          </tr><tr>
            <td class="black">28</td>
            <td>
</td>
          </tr><tr>
            <td class="black">29</td>
            <td>/**
</td>
          </tr><tr>
            <td class="black">30</td>
            <td> * Main class for analysis of sequencing data. A SparkSeqAnalysis holds Apache Spark context as well as references
</td>
          </tr><tr>
            <td class="black">31</td>
            <td> * to BAM files containing NGS data.
</td>
          </tr><tr>
            <td class="black">32</td>
            <td> *
</td>
          </tr><tr>
            <td class="black">33</td>
            <td> * @param iSC Apache Spark context.
</td>
          </tr><tr>
            <td class="black">34</td>
            <td> * @param iBAMFile  Path to the first BAM file.
</td>
          </tr><tr>
            <td class="black">35</td>
            <td> * @param iSampleId  Id of the firs sample (must be numeric).
</td>
          </tr><tr>
            <td class="black">36</td>
            <td> * @param iNormFactor  Normalization factor for doing count normalization between samples.
</td>
          </tr><tr>
            <td class="black">37</td>
            <td> * @param iReduceWorkers  Number of Reduce workers for doing transformations such as sort or join (see
</td>
          </tr><tr>
            <td class="black">38</td>
            <td> *                       http://spark.incubator.apache.org/docs/latest/scala-programming-guide.html for details).
</td>
          </tr><tr>
            <td class="black">39</td>
            <td> */
</td>
          </tr><tr>
            <td class="green">40</td>
            <td><a id="Class_pl_elka_pw_sparkseq_seqAnalysis_SparkSeqAnalysis"/> class SparkSeqAnalysis(iSC: SparkContext, iBAMFile:String,iSampleId:Int,iNormFactor:Double, iReduceWorkers:Int=8) extends Serializable
</td>
          </tr><tr>
            <td class="black">41</td>
            <td>{
</td>
          </tr><tr>
            <td class="black">42</td>
            <td>  
</td>
          </tr><tr>
            <td class="black">43</td>
            <td>  /* Spark context parameters defaults */  
</td>
          </tr><tr>
            <td class="black">44</td>
            <td>/*  val workerMem = iWorkerMem getOrElse &quot;6g&quot;
</td>
          </tr><tr>
            <td class="black">45</td>
            <td>  val serializer = iSerializer getOrElse &quot;spark.KryoSerializer&quot; 
</td>
          </tr><tr>
            <td class="black">46</td>
            <td>  val masterConnString = iMasterConnString getOrElse &quot;local&quot;
</td>
          </tr><tr>
            <td class="black">47</td>
            <td>  val sparkHome = iSparkHome getOrElse &quot;/opt/spark&quot;*/
</td>
          </tr><tr>
            <td class="black">48</td>
            <td>  
</td>
          </tr><tr>
            <td class="black">49</td>
            <td>    //val sc = iSC
</td>
          </tr><tr>
            <td class="black">50</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">51</td>
            <td>   * References to all samples in the analysis.
</td>
          </tr><tr>
            <td class="black">52</td>
            <td>   */
</td>
          </tr><tr>
            <td class="green">53</td>
            <td>    var bamFile= iSC.newAPIHadoopFile[LongWritable,SAMRecordWritable,BAMInputFormat](iBAMFile).map(r=&gt;(iSampleId,r))
</td>
          </tr><tr>
            <td class="green">54</td>
            <td>    private var bamFileFilter = bamFile
</td>
          </tr><tr>
            <td class="black">55</td>
            <td>    //val bedFile= iSC.textFile(iBEDFile)
</td>
          </tr><tr>
            <td class="black">56</td>
            <td>      
</td>
          </tr><tr>
            <td class="black">57</td>
            <td>   // val genExons = iSC.textFile(iBEDFile)
</td>
          </tr><tr>
            <td class="black">58</td>
            <td>//             .map(l =&gt; l.split(&quot;\t&quot;))
</td>
          </tr><tr>
            <td class="black">59</td>
            <td>//             .map(r=&gt;(r.array(4).trim,r.array(5).toInt,r.array(0),r.array(1).toInt,r.array(2).toInt,r.array(3)) ).toArray
</td>
          </tr><tr>
            <td class="black">60</td>
            <td>                             /*genExons format: (genId,ExonId,chr,start,end,strand)*/
</td>
          </tr><tr>
            <td class="black">61</td>
            <td>   /* val genExonsMap = scala.collection.mutable.HashMap[(String,Int,Int),(String,Int)]()
</td>
          </tr><tr>
            <td class="black">62</td>
            <td>    for(ge &lt;- genExons)
</td>
          </tr><tr>
            <td class="black">63</td>
            <td>      genExonsMap((ge._3,ge._4,ge._5)) = ((ge._1,ge._2))*/
</td>
          </tr><tr>
            <td class="black">64</td>
            <td>    //print(genExons.count)
</td>
          </tr><tr>
            <td class="black">65</td>
            <td>    //iSC.broadcast(genExons)
</td>
          </tr><tr>
            <td class="black">66</td>
            <td>             
</td>
          </tr><tr>
            <td class="green">67</td>
            <td>    private var normFactor = scala.collection.mutable.HashMap[Int,Double]()
</td>
          </tr><tr>
            <td class="green">68</td>
            <td>    normFactor(iSampleId) = iNormFactor
</td>
          </tr><tr>
            <td class="black">69</td>
            <td>  //var bedFile:RDD[String] = null
</td>
          </tr><tr>
            <td class="black">70</td>
            <td>  //val fastaFile = iFASTAFile
</td>
          </tr><tr>
            <td class="black">71</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">72</td>
            <td>   *  Method for generating bases coordinates that a given read is alligned to using its Cigar string.
</td>
          </tr><tr>
            <td class="black">73</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">74</td>
            <td>   * @param iAlignStart Start of a read alignment
</td>
          </tr><tr>
            <td class="black">75</td>
            <td>   * @param iCigar Cigar string of a read aligments
</td>
          </tr><tr>
            <td class="black">76</td>
            <td>   * @return Array of ranges computed from Cigar string.
</td>
          </tr><tr>
            <td class="black">77</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">78</td>
            <td>  private def genBasesFromCigar(iAlignStart:Int, iCigar:net.sf.samtools.Cigar ): Array[Range] = {
</td>
          </tr><tr>
            <td class="black">79</td>
            <td>    
</td>
          </tr><tr>
            <td class="green">80</td>
            <td>    var nuclReadArray = ArrayBuffer[Range]()
</td>
          </tr><tr>
            <td class="green">81</td>
            <td>    val numCigElem = iCigar.numCigarElements()
</td>
          </tr><tr>
            <td class="black">82</td>
            <td>    
</td>
          </tr><tr>
            <td class="black">83</td>
            <td>   
</td>
          </tr><tr>
            <td class="green">84</td>
            <td>    var nuclShift = 0
</td>
          </tr><tr>
            <td class="green">85</td>
            <td>    for(i &lt;- 0 to (numCigElem-1)){
</td>
          </tr><tr>
            <td class="green">86</td>
            <td>      var cElem = iCigar.getCigarElement(i)  
</td>
          </tr><tr>
            <td class="black">87</td>
            <td>      //first mapped read fragment
</td>
          </tr><tr>
            <td class="green">88</td>
            <td>      if(cElem.getOperator().toString()==&quot;M&quot; &amp;&amp; i ==0 ||(i==1 &amp;&amp; iCigar.getCigarElement(0).getOperator().toString()==&quot;S&quot; ) )
</td>
          </tr><tr>
            <td class="black">89</td>
            <td>        //nuclReadArray=Array.range(iAlignStart,iAlignStart+cElem.getLength()+1)
</td>
          </tr><tr>
            <td class="green">90</td>
            <td>        nuclReadArray+=Range(iAlignStart,iAlignStart+cElem.getLength())
</td>
          </tr><tr>
            <td class="black">91</td>
            <td>      //find maps in between    
</td>
          </tr><tr>
            <td class="green">92</td>
            <td>      else if(cElem.getOperator().toString()!=&quot;M&quot; )
</td>
          </tr><tr>
            <td class="green">93</td>
            <td>        nuclShift+=cElem.getLength()
</td>
          </tr><tr>
            <td class="green">94</td>
            <td>      else if(cElem.getOperator().toString()==&quot;M&quot; &amp;&amp; i&gt;1 &amp;&amp; i&lt;(numCigElem-1 ) &amp;&amp; nuclReadArray.length&gt;0){    
</td>
          </tr><tr>
            <td class="green">95</td>
            <td>          var mapStr=nuclReadArray.last.last+nuclShift
</td>
          </tr><tr>
            <td class="black">96</td>
            <td>        //nuclReadArray=Array.concat(nuclReadArray,Array.range(mapStr,mapStr+cElem.getLength()+1))
</td>
          </tr><tr>
            <td class="green">97</td>
            <td>          nuclReadArray+=Range(mapStr,mapStr+cElem.getLength())
</td>
          </tr><tr>
            <td class="green">98</td>
            <td>        nuclShift=0      
</td>
          </tr><tr>
            <td class="black">99</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">100</td>
            <td>       //last mapped read fragment
</td>
          </tr><tr>
            <td class="green">101</td>
            <td>       else if(cElem.getOperator().toString()==&quot;M&quot; &amp;&amp; i == (numCigElem-1) &amp;&amp; nuclReadArray.length&gt;0)
</td>
          </tr><tr>
            <td class="black">102</td>
            <td>         //nuclReadArray=Array.concat(nuclReadArray,Array.range(nuclReadArray.last+nuclShift,nuclReadArray.last+nuclShift+cElem.getLength()+1))    
</td>
          </tr><tr>
            <td class="green">103</td>
            <td>         nuclReadArray+=Range(nuclReadArray.last.last+nuclShift,nuclReadArray.last.last+nuclShift+cElem.getLength())
</td>
          </tr><tr>
            <td class="black">104</td>
            <td>    }     
</td>
          </tr><tr>
            <td class="green">105</td>
            <td>    return nuclReadArray.toArray
</td>
          </tr><tr>
            <td class="black">106</td>
            <td>    
</td>
          </tr><tr>
            <td class="black">107</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">108</td>
            <td>
</td>
          </tr><tr>
            <td class="black">109</td>
            <td>
</td>
          </tr><tr>
            <td class="black">110</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">111</td>
            <td>   * Method for adding another BAM files to intance of SparkSeqAnalysis class.
</td>
          </tr><tr>
            <td class="black">112</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">113</td>
            <td>   * @param iSC Apache Spark context.
</td>
          </tr><tr>
            <td class="black">114</td>
            <td>   * @param iBAMFile  Path to the first BAM file.
</td>
          </tr><tr>
            <td class="black">115</td>
            <td>   * @param iSampleId  Id of the firs sample (must be numeric).
</td>
          </tr><tr>
            <td class="black">116</td>
            <td>   * @param iNormFactor  Normalization factor for doing count normalization between samples.
</td>
          </tr><tr>
            <td class="black">117</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">118</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">119</td>
            <td>  def addBAM(iSC: SparkContext,iBAMFile:String,iSampleId:Int,iNormFactor:Double){
</td>
          </tr><tr>
            <td class="red">120</td>
            <td>    <span class="non">bamFile=bamFile++iSC.newAPIHadoopFile[LongWritable,SAMRecordWritable,BAMInputFormat](iBAMFile).map(r=&gt;(iSampleId,r))
</span></td>
          </tr><tr>
            <td class="red">121</td>
            <td>    <span class="non">normFactor(iSampleId) = iNormFactor
</span></td>
          </tr><tr>
            <td class="red">122</td>
            <td>    <span class="non">bamFileFilter = bamFile
</span></td>
          </tr><tr>
            <td class="black">123</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">124</td>
            <td>
</td>
          </tr><tr>
            <td class="black">125</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">126</td>
            <td>   *Method for computing coverage for a given list of genetic regions.
</td>
          </tr><tr>
            <td class="black">127</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">128</td>
            <td>   * @param iGenExons A Spark broadcast variable created from BED file that is transformed using SparkSeqConversions.BEDFileToHashMap
</td>
          </tr><tr>
            <td class="black">129</td>
            <td>   * @return RDD of tuples (regionId, coverage)
</td>
          </tr><tr>
            <td class="black">130</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">131</td>
            <td>def getCoverageRegion(iGenExons:org.apache.spark.broadcast.Broadcast[scala.collection.mutable.HashMap[String,Array[scala.collection.mutable.ArrayBuffer[(String, Int, Int, Int)]]]]):RDD[(Long,Int)] ={
</td>
          </tr><tr>
            <td class="black">132</td>
            <td>
</td>
          </tr><tr>
            <td class="black">133</td>
            <td>//iGenExons:scala.collection.mutable.HashMap[ String,Array[ArrayBuffer[(Int,Int,Int,Int)/*(GeneId,ExonId,Start,End)*/] ] ]):RDD[(Long,Int)] = {
</td>
          </tr><tr>
            <td class="black">134</td>
            <td>
</td>
          </tr><tr>
            <td class="black">135</td>
            <td>         //val genExonsB=iGenExons.value 
</td>
          </tr><tr>
            <td class="green">136</td>
            <td>   val coverage = (bamFileFilter.mapPartitions{
</td>
          </tr><tr>
            <td class="black">137</td>
            <td>      partitionIterator =&gt;
</td>
          </tr><tr>
            <td class="black">138</td>
            <td>     //var exonsCountArray = new Array[(Long,Int)](3000000)
</td>
          </tr><tr>
            <td class="green">139</td>
            <td>    var exonsCountMap = scala.collection.mutable.HashMap[Long,Int]()
</td>
          </tr><tr>
            <td class="green">140</td>
            <td>     var sampleId:Long = 0
</td>
          </tr><tr>
            <td class="green">141</td>
            <td>     var exId=0
</td>
          </tr><tr>
            <td class="green">142</td>
            <td>     var refName:String =&quot;&quot;
</td>
          </tr><tr>
            <td class="green">143</td>
            <td>    val pattern = &quot;^[A-Za-z]*0*&quot;.r
</td>
          </tr><tr>
            <td class="green">144</td>
            <td>     for (read &lt;- partitionIterator){
</td>
          </tr><tr>
            <td class="green">145</td>
            <td>        sampleId = read._1*1000000000000L
</td>
          </tr><tr>
            <td class="green">146</td>
            <td>        refName = read._2._2.get.getReferenceName
</td>
          </tr><tr>
            <td class="green">147</td>
            <td>        if( iGenExons.value.contains(refName) ){
</td>
          </tr><tr>
            <td class="green">148</td>
            <td>      var exons = iGenExons.value(refName)
</td>
          </tr><tr>
            <td class="green">149</td>
            <td>      var basesFromRead = genBasesFromCigar(read._2._2.get.getAlignmentStart, read._2._2.get.getCigar)
</td>
          </tr><tr>
            <td class="green">150</td>
            <td>      for(basesArray&lt;-basesFromRead){
</td>
          </tr><tr>
            <td class="green">151</td>
            <td>          var subReadStart = basesArray.start
</td>
          </tr><tr>
            <td class="green">152</td>
            <td>          var subReadEnd = basesArray.end
</td>
          </tr><tr>
            <td class="green">153</td>
            <td>          var idReadStart = subReadStart/10000
</td>
          </tr><tr>
            <td class="green">154</td>
            <td>          var idReadEnd = subReadEnd/10000
</td>
          </tr><tr>
            <td class="green">155</td>
            <td>          var readStartArray = exons(idReadStart)
</td>
          </tr><tr>
            <td class="green">156</td>
            <td>          if(idReadStart &gt; 0 &amp;&amp; readStartArray != null &amp;&amp; exons(idReadStart-1) != null)
</td>
          </tr><tr>
            <td class="red">157</td>
            <td>         <span class="non">readStartArray=readStartArray++(exons(idReadStart-1))
</span></td>
          </tr><tr>
            <td class="green">158</td>
            <td>          else if(idReadStart &gt; 0 &amp;&amp; readStartArray == null &amp;&amp; exons(idReadStart-1) != null)  
</td>
          </tr><tr>
            <td class="red">159</td>
            <td>          <span class="non">readStartArray = exons(idReadStart-1)
</span></td>
          </tr><tr>
            <td class="green">160</td>
            <td>          val loop = new Breaks;
</td>
          </tr><tr>
            <td class="black">161</td>
            <td>                 
</td>
          </tr><tr>
            <td class="black">162</td>
            <td>         // if(idReadStart == idReadEnd ){
</td>
          </tr><tr>
            <td class="green">163</td>
            <td>         if(readStartArray != null){
</td>
          </tr><tr>
            <td class="green">164</td>
            <td>             for(es &lt;- readStartArray)  {  
</td>
          </tr><tr>
            <td class="green">165</td>
            <td>           loop.breakable{
</td>
          </tr><tr>
            <td class="black">166</td>
            <td>              for(r &lt;-subReadStart to subReadEnd by 2) {
</td>
          </tr><tr>
            <td class="green">167</td>
            <td>             if(es._3&lt;=r &amp;&amp; es._4&gt;=r){
</td>
          </tr><tr>
            <td class="green">168</td>
            <td>                var id = sampleId+pattern.replaceAllIn(es._1,&quot;&quot;).toInt*100000L+es._2
</td>
          </tr><tr>
            <td class="green">169</td>
            <td>                if(!exonsCountMap.contains(id) )
</td>
          </tr><tr>
            <td class="green">170</td>
            <td>                  exonsCountMap(id) = 1
</td>
          </tr><tr>
            <td class="black">171</td>
            <td>                else
</td>
          </tr><tr>
            <td class="green">172</td>
            <td>                   exonsCountMap(id) += 1    
</td>
          </tr><tr>
            <td class="black">173</td>
            <td>                   //exonsCountArray(exId)= (id,1)
</td>
          </tr><tr>
            <td class="black">174</td>
            <td>                 //exId+=1
</td>
          </tr><tr>
            <td class="green">175</td>
            <td>                 loop.break
</td>
          </tr><tr>
            <td class="black">176</td>
            <td>             }
</td>
          </tr><tr>
            <td class="black">177</td>
            <td>                           
</td>
          </tr><tr>
            <td class="black">178</td>
            <td>               }
</td>
          </tr><tr>
            <td class="black">179</td>
            <td>          }
</td>
          </tr><tr>
            <td class="black">180</td>
            <td>              }
</td>
          </tr><tr>
            <td class="black">181</td>
            <td>         }
</td>
          </tr><tr>
            <td class="black">182</td>
            <td>         // }
</td>
          </tr><tr>
            <td class="black">183</td>
            <td>                
</td>
          </tr><tr>
            <td class="black">184</td>
            <td>         }
</td>
          </tr><tr>
            <td class="black">185</td>
            <td>                 
</td>
          </tr><tr>
            <td class="black">186</td>
            <td>         }
</td>
          </tr><tr>
            <td class="black">187</td>
            <td>    }
</td>
          </tr><tr>
            <td class="black">188</td>
            <td>  //}
</td>
          </tr><tr>
            <td class="black">189</td>
            <td>        /*for(e &lt;- exonsCountMap){
</td>
          </tr><tr>
            <td class="black">190</td>
            <td>    exonsCountArray(exId) = (e._1,e._2) 
</td>
          </tr><tr>
            <td class="black">191</td>
            <td>    exId+=1  
</td>
          </tr><tr>
            <td class="black">192</td>
            <td>  }*/
</td>
          </tr><tr>
            <td class="black">193</td>
            <td>  
</td>
          </tr><tr>
            <td class="green">194</td>
            <td>       Iterator(exonsCountMap)  
</td>
          </tr><tr>
            <td class="black">195</td>
            <td>   }
</td>
          </tr><tr>
            <td class="yellow">196</td>
            <td>   ).flatMap(r=&gt;r).reduceByKey(<span class="non">_+_, iReduceWorkers)
</span></td>
          </tr><tr>
            <td class="green">197</td>
            <td>   return(coverage)
</td>
          </tr><tr>
            <td class="black">198</td>
            <td>} 
</td>
          </tr><tr>
            <td class="black">199</td>
            <td>
</td>
          </tr><tr>
            <td class="black">200</td>
            <td>
</td>
          </tr><tr>
            <td class="black">201</td>
            <td> /* returns (sampleId,GeneName,ExonId,Count)*/
</td>
          </tr><tr>
            <td class="black">202</td>
            <td>/* def getCoverageExonOLD():RDD[((Int,String,Int),Int)] = {
</td>
          </tr><tr>
            <td class="black">203</td>
            <td> 
</td>
          </tr><tr>
            <td class="black">204</td>
            <td>      
</td>
          </tr><tr>
            <td class="black">205</td>
            <td>     val coverage = (bamFileFilter.mapPartitions{partitionIterator =&gt;
</td>
          </tr><tr>
            <td class="black">206</td>
            <td>     
</td>
          </tr><tr>
            <td class="black">207</td>
            <td>       var sampleId = 0
</td>
          </tr><tr>
            <td class="black">208</td>
            <td>       var id:Int = 0
</td>
          </tr><tr>
            <td class="black">209</td>
            <td>       var i = 0 
</td>
          </tr><tr>
            <td class="black">210</td>
            <td>       var count = 0
</td>
          </tr><tr>
            <td class="black">211</td>
            <td>       var minIndex = Int.MaxValue
</td>
          </tr><tr>
            <td class="black">212</td>
            <td>       var maxIndex = 0
</td>
          </tr><tr>
            <td class="black">213</td>
            <td>    val bufferSize =1000
</td>
          </tr><tr>
            <td class="black">214</td>
            <td>    var refName:String =&quot;&quot;
</td>
          </tr><tr>
            <td class="black">215</td>
            <td>    var chNumCode:Long = 0
</td>
          </tr><tr>
            <td class="black">216</td>
            <td>    var exonsCountMap = scala.collection.mutable.HashMap[(String,Int),Int]()
</td>
          </tr><tr>
            <td class="black">217</td>
            <td>    var exonsCountArray = new Array[((Int,String,Int),Int)](500000)  
</td>
          </tr><tr>
            <td class="black">218</td>
            <td>       for (read &lt;- partitionIterator){
</td>
          </tr><tr>
            <td class="black">219</td>
            <td>         sampleId = read._1
</td>
          </tr><tr>
            <td class="black">220</td>
            <td>         refName = read._2._2.get.getReferenceName
</td>
          </tr><tr>
            <td class="black">221</td>
            <td>         var exons = genExons.filter(r=&gt;(r._3==refName))
</td>
          </tr><tr>
            <td class="black">222</td>
            <td>            //chNumCode = chrToLong(refName)+sampleId*1000000000000L
</td>
          </tr><tr>
            <td class="black">223</td>
            <td>            var basesFromRead = genBasesFromCigar(read._2._2.get.getAlignmentStart, read._2._2.get.getCigar)
</td>
          </tr><tr>
            <td class="black">224</td>
            <td>            for(basesArray&lt;-basesFromRead){
</td>
          </tr><tr>
            <td class="black">225</td>
            <td>              var subReadStart = basesArray.start
</td>
          </tr><tr>
            <td class="black">226</td>
            <td>              var subReadEnd = basesArray.end
</td>
          </tr><tr>
            <td class="black">227</td>
            <td>             
</td>
          </tr><tr>
            <td class="black">228</td>
            <td>              exons = exons.filter(e=&gt; (e._4 &gt;= subReadStart &amp;&amp; e._4&lt;= subReadEnd &amp;&amp;  e._5 &gt;= subReadEnd) || 
</td>
          </tr><tr>
            <td class="black">229</td>
            <td>                     ( e._4 &lt;= subReadStart  &amp;&amp; e._5 &gt;= subReadStart &amp;&amp;  e._5 &lt;= subReadEnd)  || (e._4 &gt;= subReadStart  &amp;&amp;  e._5 &lt;= subReadEnd) ) 
</td>
          </tr><tr>
            <td class="black">230</td>
            <td>              if(exons.length&gt;0){
</td>
          </tr><tr>
            <td class="black">231</td>
            <td>                for(ex &lt;- exons){
</td>
          </tr><tr>
            <td class="black">232</td>
            <td>                  if(exonsCountMap.contains( (ex._1,ex._2)) )
</td>
          </tr><tr>
            <td class="black">233</td>
            <td>                    exonsCountMap((ex._1,ex._2)) += 1
</td>
          </tr><tr>
            <td class="black">234</td>
            <td>                  else
</td>
          </tr><tr>
            <td class="black">235</td>
            <td>                    exonsCountMap((ex._1,ex._2)) = 1
</td>
          </tr><tr>
            <td class="black">236</td>
            <td>                }
</td>
          </tr><tr>
            <td class="black">237</td>
            <td>              }
</td>
          </tr><tr>
            <td class="black">238</td>
            <td>            }
</td>
          </tr><tr>
            <td class="black">239</td>
            <td>          
</td>
          </tr><tr>
            <td class="black">240</td>
            <td>   }
</td>
          </tr><tr>
            <td class="black">241</td>
            <td>   for(exCount &lt;- exonsCountMap){
</td>
          </tr><tr>
            <td class="black">242</td>
            <td>     exonsCountArray(i) = ((sampleId,exCount._1._1,exCount._1._2),exCount._2)
</td>
          </tr><tr>
            <td class="black">243</td>
            <td>     i+=1
</td>
          </tr><tr>
            <td class="black">244</td>
            <td>   }
</td>
          </tr><tr>
            <td class="black">245</td>
            <td>   Iterator(exonsCountArray.filter(r=&gt;r!=null))
</td>
          </tr><tr>
            <td class="black">246</td>
            <td>   }).flatMap(r=&gt;r).reduceByKey(_+_, iReduceWorkers)
</td>
          </tr><tr>
            <td class="black">247</td>
            <td>   return(coverage)
</td>
          </tr><tr>
            <td class="black">248</td>
            <td> }
</td>
          </tr><tr>
            <td class="black">249</td>
            <td>  
</td>
          </tr><tr>
            <td class="black">250</td>
            <td>def getCoverageExonOLD2():RDD[((Int,String,Int),Int)] = {
</td>
          </tr><tr>
            <td class="black">251</td>
            <td> 
</td>
          </tr><tr>
            <td class="black">252</td>
            <td>      
</td>
          </tr><tr>
            <td class="black">253</td>
            <td>     val coverage = (bamFileFilter.mapPartitions{partitionIterator =&gt;
</td>
          </tr><tr>
            <td class="black">254</td>
            <td>     
</td>
          </tr><tr>
            <td class="black">255</td>
            <td>       var sampleId = 0
</td>
          </tr><tr>
            <td class="black">256</td>
            <td>       var id:Int = 0
</td>
          </tr><tr>
            <td class="black">257</td>
            <td>       var i = 0 
</td>
          </tr><tr>
            <td class="black">258</td>
            <td>       var count = 0
</td>
          </tr><tr>
            <td class="black">259</td>
            <td>       var minIndex = Int.MaxValue
</td>
          </tr><tr>
            <td class="black">260</td>
            <td>       var maxIndex = 0
</td>
          </tr><tr>
            <td class="black">261</td>
            <td>  val bufferSize =1000
</td>
          </tr><tr>
            <td class="black">262</td>
            <td>  var refName:String =&quot;&quot;
</td>
          </tr><tr>
            <td class="black">263</td>
            <td>  var chNumCode:Long = 0
</td>
          </tr><tr>
            <td class="black">264</td>
            <td>  var chrMin = scala.collection.mutable.HashMap[String,Int]()
</td>
          </tr><tr>
            <td class="black">265</td>
            <td>  var chrMax = scala.collection.mutable.HashMap[String,Int]()
</td>
          </tr><tr>
            <td class="black">266</td>
            <td>  var exonsCountMap = scala.collection.mutable.HashMap[(String,Int),Int]()
</td>
          </tr><tr>
            <td class="black">267</td>
            <td>    
</td>
          </tr><tr>
            <td class="black">268</td>
            <td>  var chrMap = scala.collection.mutable.HashMap[Long,Array[(Int,Int)] ]()
</td>
          </tr><tr>
            <td class="black">269</td>
            <td>    
</td>
          </tr><tr>
            <td class="black">270</td>
            <td>  var exonsCountArray = new Array[((Int,String,Int),Int)](50000)
</td>
          </tr><tr>
            <td class="black">271</td>
            <td>  var readsArray = new Array[(Long,Int,Int)](2000000)
</td>
          </tr><tr>
            <td class="black">272</td>
            <td>       for (read &lt;- partitionIterator){
</td>
          </tr><tr>
            <td class="black">273</td>
            <td>         sampleId = read._1
</td>
          </tr><tr>
            <td class="black">274</td>
            <td>         refName = read._2._2.get.getReferenceName
</td>
          </tr><tr>
            <td class="black">275</td>
            <td>         chNumCode = chrToLong(refName)
</td>
          </tr><tr>
            <td class="black">276</td>
            <td>         if(!chrMin.contains(refName))
</td>
          </tr><tr>
            <td class="black">277</td>
            <td>              chrMin(refName)=Int.MaxValue
</td>
          </tr><tr>
            <td class="black">278</td>
            <td>            if(chrMin(refName)&gt;read._2._2.get.getAlignmentStart)
</td>
          </tr><tr>
            <td class="black">279</td>
            <td>              chrMin(refName) = read._2._2.get.getAlignmentStart  
</td>
          </tr><tr>
            <td class="black">280</td>
            <td>            
</td>
          </tr><tr>
            <td class="black">281</td>
            <td>            if(!chrMax.contains(refName))
</td>
          </tr><tr>
            <td class="black">282</td>
            <td>              chrMax(refName)= 0 
</td>
          </tr><tr>
            <td class="black">283</td>
            <td>            if(chrMax(refName)&lt; read._2._2.get.getAlignmentEnd)
</td>
          </tr><tr>
            <td class="black">284</td>
            <td>              chrMax(refName) = read._2._2.get.getAlignmentEnd
</td>
          </tr><tr>
            <td class="black">285</td>
            <td>            var basesFromRead = genBasesFromCigar(read._2._2.get.getAlignmentStart, read._2._2.get.getCigar)
</td>
          </tr><tr>
            <td class="black">286</td>
            <td>            for(bRange &lt;- basesFromRead){
</td>
          </tr><tr>
            <td class="black">287</td>
            <td>              readsArray(i) = (chNumCode,bRange.start,bRange.end)
</td>
          </tr><tr>
            <td class="black">288</td>
            <td>              i+=1
</td>
          </tr><tr>
            <td class="black">289</td>
            <td>            }
</td>
          </tr><tr>
            <td class="black">290</td>
            <td>   }
</td>
          </tr><tr>
            <td class="black">291</td>
            <td>     readsArray = readsArray.filter(r=&gt;r!=null)
</td>
          </tr><tr>
            <td class="black">292</td>
            <td>     var genExonsPruned= Array[(java.lang.String, Int, java.lang.String, Int, Int, java.lang.String)]()
</td>
          </tr><tr>
            <td class="black">293</td>
            <td>     for(chr &lt;- chrMax){
</td>
          </tr><tr>
            <td class="black">294</td>
            <td>       
</td>
          </tr><tr>
            <td class="black">295</td>
            <td>       genExonsPruned=Array.concat(genExonsPruned,genExons.filter(e=&gt;(e._3 == chr._1 ) &amp;&amp; (e._4 &gt;= chrMin(chr._1) &amp;&amp; e._4&lt;= chrMax(chr._1) &amp;&amp;  e._5 &gt;= chrMax(chr._1) || 
</td>
          </tr><tr>
            <td class="black">296</td>
            <td>                    ( e._4 &lt;= chrMin(chr._1)  &amp;&amp; e._5 &gt;= chrMin(chr._1) &amp;&amp;  e._5 &lt;= chrMax(chr._1))  || (e._4 &gt;= chrMin(chr._1)  &amp;&amp;  e._5 &lt;= chrMax(chr._1) ) ) )   )
</td>
          </tr><tr>
            <td class="black">297</td>
            <td>     }
</td>
          </tr><tr>
            <td class="black">298</td>
            <td>     genExonsPruned = genExonsPruned.filter(e=&gt;e!=null)
</td>
          </tr><tr>
            <td class="black">299</td>
            <td>     i = 0
</td>
          </tr><tr>
            <td class="black">300</td>
            <td>     for(ex &lt;- genExonsPruned){
</td>
          </tr><tr>
            <td class="black">301</td>
            <td>       if(ex != null){
</td>
          </tr><tr>
            <td class="black">302</td>
            <td>         var chr = chrToLong(ex._3)
</td>
          </tr><tr>
            <td class="black">303</td>
            <td>         var subReadStart = ex._4
</td>
          </tr><tr>
            <td class="black">304</td>
            <td>         var subReadEnd = ex._5
</td>
          </tr><tr>
            <td class="black">305</td>
            <td>         //var count = readsArray.filter(r=&gt;(r._1 == chr &amp;&amp; (r._2 &gt;= subReadStart &amp;&amp; r._2&lt;= subReadEnd &amp;&amp;  r._3 &gt;= subReadEnd) || 
</td>
          </tr><tr>
            <td class="black">306</td>
            <td>         //              ( r._2 &lt;= subReadStart  &amp;&amp; r._3 &gt;= subReadStart &amp;&amp;  r._3 &lt;= subReadEnd)  || (r._2 &gt;= subReadStart  &amp;&amp;  r._3 &lt;= subReadEnd))   ).length
</td>
          </tr><tr>
            <td class="black">307</td>
            <td>         var count = 1
</td>
          </tr><tr>
            <td class="black">308</td>
            <td>         if(count&gt;0)
</td>
          </tr><tr>
            <td class="black">309</td>
            <td>             //exonsCountMap((ex._1,ex._2)) = count
</td>
          </tr><tr>
            <td class="black">310</td>
            <td>             exonsCountArray(i) = ((sampleId,ex._1,ex._2),count)
</td>
          </tr><tr>
            <td class="black">311</td>
            <td>             i+=1
</td>
          </tr><tr>
            <td class="black">312</td>
            <td>         }
</td>
          </tr><tr>
            <td class="black">313</td>
            <td>     }
</td>
          </tr><tr>
            <td class="black">314</td>
            <td>     /*i = 0
</td>
          </tr><tr>
            <td class="black">315</td>
            <td>   for(exCount &lt;- exonsCountMap){
</td>
          </tr><tr>
            <td class="black">316</td>
            <td>     exonsCountArray(i) = ((sampleId,exCount._1._1,exCount._1._2),exCount._2)
</td>
          </tr><tr>
            <td class="black">317</td>
            <td>     i+=1
</td>
          </tr><tr>
            <td class="black">318</td>
            <td>   }*/
</td>
          </tr><tr>
            <td class="black">319</td>
            <td>   Iterator(exonsCountArray.filter(r=&gt;r!=null))
</td>
          </tr><tr>
            <td class="black">320</td>
            <td>   }).flatMap(r=&gt;r).reduceByKey(_+_, iReduceWorkers)
</td>
          </tr><tr>
            <td class="black">321</td>
            <td>   return(coverage)
</td>
          </tr><tr>
            <td class="black">322</td>
            <td> }
</td>
          </tr><tr>
            <td class="black">323</td>
            <td>*/
</td>
          </tr><tr>
            <td class="black">324</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">325</td>
            <td>   * Method for computing coverage of all bases.
</td>
          </tr><tr>
            <td class="black">326</td>
            <td>   * @return RDD of tuples (genID, coverage)
</td>
          </tr><tr>
            <td class="black">327</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">328</td>
            <td>  def getCoverageBase() : RDD[(Long,Int)]= {
</td>
          </tr><tr>
            <td class="green">329</td>
            <td>    val coverage = (bamFileFilter.mapPartitions{partitionIterator =&gt;
</td>
          </tr><tr>
            <td class="green">330</td>
            <td>    var sampleId = 0
</td>
          </tr><tr>
            <td class="green">331</td>
            <td>    var id:Int = 0
</td>
          </tr><tr>
            <td class="green">332</td>
            <td>    var i = 0 
</td>
          </tr><tr>
            <td class="green">333</td>
            <td>    var count = 0
</td>
          </tr><tr>
            <td class="green">334</td>
            <td>    var minIndex = Int.MaxValue
</td>
          </tr><tr>
            <td class="green">335</td>
            <td>    var maxIndex = 0
</td>
          </tr><tr>
            <td class="green">336</td>
            <td>    var chrMap = scala.collection.mutable.HashMap[Long,Array[Array[Int]]]()
</td>
          </tr><tr>
            <td class="green">337</td>
            <td>    var chrMin = scala.collection.mutable.HashMap[Long,Int]()
</td>
          </tr><tr>
            <td class="green">338</td>
            <td>    var chrMax = scala.collection.mutable.HashMap[Long,Int]()
</td>
          </tr><tr>
            <td class="green">339</td>
            <td>    val bufferSize =150000
</td>
          </tr><tr>
            <td class="green">340</td>
            <td>    var refName:String =&quot;&quot;
</td>
          </tr><tr>
            <td class="green">341</td>
            <td>    var chNumCode:Long = 0
</td>
          </tr><tr>
            <td class="black">342</td>
            <td>    //val nuclArray = new Array[Array[Int]](2000000)
</td>
          </tr><tr>
            <td class="green">343</td>
            <td>    var countArray = new Array[(Long,Int)](12000000)
</td>
          </tr><tr>
            <td class="green">344</td>
            <td>    var countArrayToReduce = new Array[(Long,Int)](300000)
</td>
          </tr><tr>
            <td class="green">345</td>
            <td>    var outputArray = new   Array[Array[(Long,Int)]](2)
</td>
          </tr><tr>
            <td class="black">346</td>
            <td>
</td>
          </tr><tr>
            <td class="green">347</td>
            <td>    for (read &lt;- partitionIterator){
</td>
          </tr><tr>
            <td class="green">348</td>
            <td>      sampleId = read._1
</td>
          </tr><tr>
            <td class="green">349</td>
            <td>        refName = read._2._2.get.getReferenceName
</td>
          </tr><tr>
            <td class="green">350</td>
            <td>            chNumCode = SparkSeqConversions.chrToLong(refName)+sampleId*1000000000000L
</td>
          </tr><tr>
            <td class="black">351</td>
            <td>            
</td>
          </tr><tr>
            <td class="green">352</td>
            <td>            if(!chrMin.contains(chNumCode))
</td>
          </tr><tr>
            <td class="green">353</td>
            <td>              chrMin(chNumCode)=Int.MaxValue
</td>
          </tr><tr>
            <td class="green">354</td>
            <td>            if(chrMin(chNumCode)&gt;read._2._2.get.getAlignmentStart)
</td>
          </tr><tr>
            <td class="green">355</td>
            <td>              chrMin(chNumCode) = read._2._2.get.getAlignmentStart  
</td>
          </tr><tr>
            <td class="black">356</td>
            <td>            
</td>
          </tr><tr>
            <td class="green">357</td>
            <td>            if(!chrMax.contains(chNumCode))
</td>
          </tr><tr>
            <td class="green">358</td>
            <td>              chrMax(chNumCode)= 0 
</td>
          </tr><tr>
            <td class="green">359</td>
            <td>            if(chrMax(chNumCode)&lt; read._2._2.get.getAlignmentEnd)
</td>
          </tr><tr>
            <td class="green">360</td>
            <td>              chrMax(chNumCode) = read._2._2.get.getAlignmentEnd    
</td>
          </tr><tr>
            <td class="green">361</td>
            <td>          var basesFromRead = genBasesFromCigar(read._2._2.get.getAlignmentStart, read._2._2.get.getCigar)
</td>
          </tr><tr>
            <td class="black">362</td>
            <td>          //new chr in reads
</td>
          </tr><tr>
            <td class="green">363</td>
            <td>          if(!chrMap.contains(chNumCode))
</td>
          </tr><tr>
            <td class="green">364</td>
            <td>               chrMap(chNumCode) = new Array[Array[Int]](2500000)
</td>
          </tr><tr>
            <td class="green">365</td>
            <td>          for(basesArray&lt;-basesFromRead){
</td>
          </tr><tr>
            <td class="green">366</td>
            <td>             for(rb&lt;-basesArray)
</td>
          </tr><tr>
            <td class="black">367</td>
            <td>            {
</td>
          </tr><tr>
            <td class="black">368</td>
            <td>              //id = chNumCode+baseRange(j)
</td>
          </tr><tr>
            <td class="green">369</td>
            <td>             id = (rb % 100)
</td>
          </tr><tr>
            <td class="green">370</td>
            <td>             var idIn=rb/100
</td>
          </tr><tr>
            <td class="green">371</td>
            <td>            if( chrMap(chNumCode)(idIn) == null)
</td>
          </tr><tr>
            <td class="green">372</td>
            <td>               chrMap(chNumCode)(idIn) = Array.fill(100)(0)
</td>
          </tr><tr>
            <td class="green">373</td>
            <td>             chrMap(chNumCode)(idIn)(id)+=1
</td>
          </tr><tr>
            <td class="black">374</td>
            <td>            }
</td>
          </tr><tr>
            <td class="black">375</td>
            <td>          }
</td>
          </tr><tr>
            <td class="black">376</td>
            <td>          
</td>
          </tr><tr>
            <td class="black">377</td>
            <td>        }
</td>
          </tr><tr>
            <td class="green">378</td>
            <td>    i=0
</td>
          </tr><tr>
            <td class="green">379</td>
            <td>    var k = 0
</td>
          </tr><tr>
            <td class="green">380</td>
            <td>    for(chr&lt;-chrMap){  
</td>
          </tr><tr>
            <td class="green">381</td>
            <td>      for(j&lt;-0 to chr._2.length-1){
</td>
          </tr><tr>
            <td class="green">382</td>
            <td>      if(chr._2(j) != null){
</td>
          </tr><tr>
            <td class="green">383</td>
            <td>        for(r&lt;-0 to 99){
</td>
          </tr><tr>
            <td class="green">384</td>
            <td>          if(chr._2(j)(r)&gt;0){
</td>
          </tr><tr>
            <td class="green">385</td>
            <td>            var idx = j*100+r
</td>
          </tr><tr>
            <td class="green">386</td>
            <td>            if( idx&lt;=(chrMin(chr._1)+bufferSize) || idx&gt;=(chrMax(chr._1)-bufferSize) ){
</td>
          </tr><tr>
            <td class="green">387</td>
            <td>              countArrayToReduce(k) = ( (chr._1+idx, math.round(chr._2(j)(r) *normFactor(sampleId)).toInt) )
</td>
          </tr><tr>
            <td class="green">388</td>
            <td>              k+=1    
</td>
          </tr><tr>
            <td class="black">389</td>
            <td>            }
</td>
          </tr><tr>
            <td class="black">390</td>
            <td>            else{
</td>
          </tr><tr>
            <td class="red">391</td>
            <td>              <span class="non">countArray(i) = ( (chr._1+idx, math.round(chr._2(j)(r) *normFactor(sampleId)).toInt ) )
</span></td>
          </tr><tr>
            <td class="red">392</td>
            <td>                <span class="non">i+=1
</span></td>
          </tr><tr>
            <td class="black">393</td>
            <td>            }
</td>
          </tr><tr>
            <td class="black">394</td>
            <td>              
</td>
          </tr><tr>
            <td class="black">395</td>
            <td>          }  
</td>
          </tr><tr>
            <td class="black">396</td>
            <td>        }  
</td>
          </tr><tr>
            <td class="black">397</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">398</td>
            <td>      
</td>
          </tr><tr>
            <td class="black">399</td>
            <td>      }
</td>
          </tr><tr>
            <td class="black">400</td>
            <td>    }
</td>
          </tr><tr>
            <td class="green">401</td>
            <td>    outputArray(0) = countArray.filter(r=&gt;r!=null)
</td>
          </tr><tr>
            <td class="green">402</td>
            <td>    outputArray(1) = countArrayToReduce.filter(r=&gt;r!=null)
</td>
          </tr><tr>
            <td class="green">403</td>
            <td>    Iterator(outputArray)
</td>
          </tr><tr>
            <td class="black">404</td>
            <td>    } )
</td>
          </tr><tr>
            <td class="yellow">405</td>
            <td>    val coverageToReduce = coverage.flatMap(r =&gt;(r.array(1)) ).reduceByKey(<span class="non">_+_, iReduceWorkers)
</span></td>
          </tr><tr>
            <td class="green">406</td>
            <td>    val coverageNotReduce = coverage.flatMap(r =&gt;(r.array(0)) )
</td>
          </tr><tr>
            <td class="green">407</td>
            <td>    bamFileFilter=bamFile
</td>
          </tr><tr>
            <td class="green">408</td>
            <td>    return (coverageNotReduce.union(coverageToReduce) )
</td>
          </tr><tr>
            <td class="black">409</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">410</td>
            <td>
</td>
          </tr><tr>
            <td class="black">411</td>
            <td>  /**
</td>
          </tr><tr>
            <td class="black">412</td>
            <td>   * Method for computing coverage of all bases from a give chromosome region.
</td>
          </tr><tr>
            <td class="black">413</td>
            <td>   *
</td>
          </tr><tr>
            <td class="black">414</td>
            <td>   * @param chr Chromosome (eg. chr1)
</td>
          </tr><tr>
            <td class="black">415</td>
            <td>   * @param regStart Starting position in a chromosome.
</td>
          </tr><tr>
            <td class="black">416</td>
            <td>   * @param regEnd End position in a chromosome.
</td>
          </tr><tr>
            <td class="black">417</td>
            <td>   * @return RDD of tuples (genID, coverage)
</td>
          </tr><tr>
            <td class="black">418</td>
            <td>   */
</td>
          </tr><tr>
            <td class="black">419</td>
            <td>  def getCoverageBaseRegion(chr:String, regStart:Int, regEnd:Int): RDD[(Long,Int)]={
</td>
          </tr><tr>
            <td class="black">420</td>
            <td>    //val chrCode = chrToLong(chr)
</td>
          </tr><tr>
            <td class="green">421</td>
            <td>    if(chr==&quot;*&quot;)
</td>
          </tr><tr>
            <td class="red">422</td>
            <td>      <span class="non">bamFileFilter=bamFile.filter(r =&gt; r._2._2.get.getAlignmentStart()&gt;=regStart &amp;&amp; r._2._2.get.getAlignmentEnd()&lt;=regEnd)
</span></td>
          </tr><tr>
            <td class="black">423</td>
            <td>    else  
</td>
          </tr><tr>
            <td class="green">424</td>
            <td>      bamFileFilter=bamFile.filter(r =&gt; r._2._2.get.getReferenceName()==chr &amp;&amp; r._2._2.get.getAlignmentStart()&gt;=regStart &amp;&amp; r._2._2.get.getAlignmentEnd()&lt;=regEnd)
</td>
          </tr><tr>
            <td class="black">425</td>
            <td>    
</td>
          </tr><tr>
            <td class="green">426</td>
            <td>    return(getCoverageBase())
</td>
          </tr><tr>
            <td class="black">427</td>
            <td>    
</td>
          </tr><tr>
            <td class="black">428</td>
            <td>  }
</td>
          </tr><tr>
            <td class="black">429</td>
            <td>  
</td>
          </tr><tr>
            <td class="black">430</td>
            <td>
</td>
          </tr><tr>
            <td class="black">431</td>
            <td>    
</td>
          </tr><tr>
            <td class="black">432</td>
            <td>  
</td>
          </tr><tr>
            <td class="black">433</td>
            <td>}
</td>
          </tr><tr>
            <td class="black">434</td>
            <td>  
</td>
          </tr></tbody></table>